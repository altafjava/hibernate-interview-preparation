1. JDBC vs Hibernate.
2. Session vs SessionFactory.
3. How to create Session & SessionFactory?
4. SessionFactory vs EntityManagerFactory.
5. What is Dialect?
6. What is an Entity Lifecycle?

   Transient, Persistent/Managed, Detached, Removed

   |                       |                                                        |
   | --------------------- | ------------------------------------------------------ |
   | Transient->Persistent | save(), persist(), saveOrUpdate()                      |
   | Persistent->Transient | delete()                                               |
   | Detached->Persistent  | merge(), update(), saveOrUpdate(), replicate(), lock() |
   | Persistent->Removed   | remove()                                               |
   | DB->Persistent        | find(), get(), load()                                  |
   | Removed->Persistent   | save(), persist()                                      |

7. Can we create an Entity class without primary key columns?
8. What are the rules for creating an Entity class?

   1. No-Arg Constructor
   2. Provide an identifier properly
   3. Declare getters/setters
   4. Entity class should not be final because Hibernate uses proxies concept of lazy fetching

9. Is SessionFactory thread safe? Yes
10. Is Session thread safe? No
11. What is the CREATE TABLE query generated by Hibernate?

```sql
create table Employee (employeeId integer not null auto_increment, email varchar(255), firstName varchar(255), lastName varchar(255), primary key (employeeId)) engine=MyISAM
```

12. What is the INSERT query generated by Hibernate?

```sql
insert into Employee (email, firstName, lastName) values (?, ?, ?)
```

13. What are Entity Lifecycle events & callbacks?

    Whenever we call methods in the Session interface to persist, update or delete the entities, the session generates an appropriate event based on the executed method and passes it to the configured event listener(s) for that type. The event types are declared as enum values on org.hibernate.event.spi.EventType. For example, when we persist an entity using the session.persist() method then an event EventType.PERSIST is generated. If there are any PersistEventListener implementation registered for that Entity then the event is passed to that listener for processing.

14. How to create EventListener?
    Create a class and implements any the of the EventListerner interface and override its methods. For example PersistEventListener is the interface for PERSIST event.

    ```java
    public void onPersist(PersistEvent persistEvent) throws HibernateException
    public void onPersist(PersistEvent event, PersistContext createdAlready) throws HibernateException
    ```

15. How to register EventListener?

    To register the event listeners, we need to create our own implementation of `org.hibernate.integrator.spi.Integrator` interface. The main use of Integrator is to register the event listeners. Create a class and implements `org.hibernate.integrator.spi.Integrator` and override its methods.

    ```java
      public void integrate(Metadata metadata, SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry)

      public void integrate(Metadata metadata, BootstrapContext bootstrapContext, SessionFactoryImplementor sessionFactory)

      public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry)
    ```

    The Integrator is then registered with the persistent context with the help of `BootstrapServiceRegistryBuilder`. Note that `BootstrapServiceRegistry` is intended to hold mainly 3 services that Hibernate needs at both bootstrap and run time.

    1. ClassLoaderService
    2. IntegratorService
    3. StrategySelector.

    After creating the `BootstrapServiceRegistery`, Now supply the custom `BootstrapServiceRegistry` instance to the `StandardServiceRegistry` and build the SessionFactory.

    ```java
    BootstrapServiceRegistryBuilder bootstrapServiceRegistryBuilder = new BootstrapServiceRegistryBuilder();

    bootstrapServiceRegistryBuilder.applyIntegrator(new AppIntegrator());

    BootstrapServiceRegistry bootstrapServiceRegistry = bootstrapServiceRegistryBuilder.build();

    StandardServiceRegistry standardServiceRegistry = new StandardServiceRegistryBuilder(bootstrapServiceRegistry).configure().build();

    Metadata metadata = new MetadataSources(standardServiceRegistry).getMetadataBuilder().build();

    SessionFactory sessionFactory = metadata.getSessionFactoryBuilder().build();
    ```

16. How to check Entity equality between Sessions?

    Requesting a persistent/managed object again from the same Hibernate session returns the “same instance” of a class.
    Requesting a persistent object from the different Hibernate sessions returns the "different instances" of a class.
    Hence as a best practice, always implement equals() and hashCode() methods in the hibernate entities; and always compare them using equals() method only.

17. save()

    This method is used to save Entity into DB and returns the primary key. This makes a TRANSIENT entity to PERSISTENT. We can use this method outside a transaction. Means without transaction also we can save the entity. If we have multiple entities with mapping among them(OTO, OTM, MTO, MTM) and if we are saving outside the transaction then only primary(parent) entity will be saved. Lets say We have Cart entity mapped with Item entity as One to Many. Cart can have multiple items. If we are saving cart without transaction then only Cart entity will be saved. Item entity will not be saved. Even we start the transaction and don’t flush or commit then still Item will not be saved. We must either flush or commit then mapped entity will be saved. Hence we should avoid save outside transaction boundary. This will led the data inconsistency problem.

    We can store a DETACHED entity using this method. It will create a new primary key for that Detached entity but the associated entity will not create a new record(new primary key) ; rather for the associated entity it will execute an update query which does nothing.

    ```java
    Session session = sessionFactory.openSession();
    Transaction transaction = session.beginTransaction();
    session.save(employee);
    transaction.commit();
    transaction = session.beginTransaction();
    session.evict(employee);
    session.save(employee);
    transaction.commit();
    ```

    ```sql
    Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)
    Hibernate: insert into Address (city, zipcode, id) values (?, ?, ?)
    Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)
    Hibernate: update Address set city=?, zipcode=? where id=?
    ```

18. persist()

    This method is also used to save the entity into DB(Transient to Persistent) but it does not return anything and it works only inside the transaction. If we have mapped entities and we have begun the transaction but did not flush or commit then only the parent entity will be saved not the child entity. To save all the mapped entities we must commit or flush the session. We cannot store a DETACHED entity using this method. We shall get exception

19. saveOrUpdate()

    This method is used for either insert or update queries based on the provided data. If the data is present in the database(Means it is a Persistent entity) then an update query is executed. If the data is not present in the database(means it is a Transient entity) then insert query will be executed. If we have a Persistent entity and we did not change anything in those entities then nothing will happen(neither insert or update).

    We can use this method without transaction too, but again we shall face the issues with mapped objects. Only the primary(parent) entity will be saved. If we want to save all the mapped entities then we must start the transaction and either flush or commit. It does not return anything.
    We cannot store a DETACHED entity using this method. If we try to do so then it will execute an update query which does nothing.

20. update()

    This method should be used where we know that we are only updating the entity information. This will only work with Persistent entities. If we are trying to update a Transient entity and a transaction is started and we are doing either flush or commit then we shall get an exception. If a transaction has started and we are doing flush/commit then nothing will happen.

    If the entity is in Persistent state and we are modifying anything then nothing will happen. This method only works with transactions. We must start the transaction and either flush or commit. Otherwise nothing will happen. If we are updating the Persistent entity inside the transaction and the updated data is the same with the Persistent entity then it will not execute the update query. It will remain the same.

21. merge()

    The main purpose of the merge method is to make a DETACHED entity to PERSISTENT. Without a transaction it does not work. We must start the transaction. This method is almost the same as saveOrUpdate except it returns the PERSISTENT entity and does not throw NonUniqueObjectException.

    If we have a DETACHED entity Employee and we want to make this as PERSISTENT entity and that session already has and entity with the same id(primary key) with that DETACHED entity, we shall get NonUniqueObjectException if we shall use update() or saveOrUpdate() methods. But if we use the merge() method then it will work perfectly without any exception.

    ```java
    Session session = sessionFactory.openSession();
    Transaction transaction = session.beginTransaction();
    Employee employee = session.get(Employee.class, 2);
    session.evict(employee);
    employee.setFirstName("James");
    Employee employee2 = session.get(Employee.class, 2);
    // session.saveOrUpdate(employee); // NonUniqueObjectException
    // session.update(employee); // NonUniqueObjectException
    session.merge(employee);
    Employee mergedEmployee = session.merge(employee);
    ```

    If we are saving an TRANSIENT Employee entity which has an associated entity Address and we did not flush/commit then only the Employee entity will be saved. If we do either flush or commit then the associated entity Address will be saved.

    If we want to update the Persistent entity then we must start the transaction and flush/commit then will work. If we are updating the Persistent entity inside the transaction and the updated data is the same with the Persistent entity then it will not execute the update query. It will remain the same. If we are updating the Persistent entity inside the transaction and the updated data is different with the Persistent entity then it will execute the update query.

22. Get vs Load

    The entity loaded with `get()` method is eager loaded and contains information from the database. Whereas the entity loaded from `load()` method is a lazy load proxy object that queries the database when any field information is accessed. Hibernate internally uses ByteBuddy to create proxy classes at runtime.

    In the case of the `get()` method, we will get the return value as NULL if the identifier is absent. But in the case of `load()` method, we will get an `ObjectNotFoundException`.

    `load()` method is deprecated since Hibernate 6.0. It is recommended to use the getReference() method instead of the `load()` method.

    ```sql
    Hibernate uses LEFT JOIN to fetch the single entity.
    select e1_0.id,a1_0.id,a1_0.city,a1_0.zipcode,e1_0.firstName,e1_0.lastName,e1_0.salary from Employee e1_0 left join Address a1_0 on e1_0.id=a1_0.id where e1_0.id=?
    ```

23. refresh()

    Sometimes we face a situation when our application database is modified with some external application/agent and thus corresponding hibernate entity in your application actually becomes out of sync with its database representation i.e. having old data. In this case, we can use the session.refresh() method to re-populate the entity with the latest data available in the database.

24. delete()/remove()

    Both methods are used to delete a single entity. If the passed entity is not present in the database then we shall get an ObjectNotFoundException. Both methods work on DETACHED entities as well if we are using Hibernate Session. But in the case of JPA, the EntityManager delete() method cannot delete the DETACHED entity. This will give IllegalArgumentException.

    ```java
     EmployeeEntity employee = entityManager.find(Employee.class, 1L);
     entityManager.detach(employee);
     entityManager.remove(employee);
    ```

    If there is any associated entity, then first associated entity will be deleted then the parent entity. delete() method is deprecated since Hibernate 6.0. It is recommended to use the remove() method.

    ```sql
    Hibernate: delete from Address where id=?
    Hibernate: delete from Employee where id=?
    ```

    The EntityManager.remove() and Session.remove() methods are a better fit when we want to delete a single Entity but inefficient if we want to remove a list of entities. For each remove() call, hibernate loads the entity, performs the lifecycle transition to REMOVED and triggers the SQL DELETE operation. Executing N different SQL DELETE queries for N entities will lead to very inefficient performance. It’s often better to remove such a list of entities with a JPQL query.

    We should flush all the pending changes to the database before executing the query so that we are making changes to the latest data. And we also minimize the risk of stale first-level cache.

    ```java
    session.flush();
    session.clear();
    //Get list of Ids
    List<Long> ids = getIdsToDelete();
    //Remove all entities
    Query query = em.createQuery("DELETE EmployeeEntity e WHERE id IN (:ids)");
    query.setParameter("ids", ids);
    query.executeUpdate();
    ```

25. @Entity

    This annotation is used to make the POJO class as JPA Entity.
    Entity class must have a no-argument constructor without private access modifier, otherwise we shall get NoSuchMethodException.
    Entity class must not be an abstract class because Hibernate creates the object of Entity class by using newInstance() method and as we know Abstract class cannot be instantiated.
    We can declare Entity class as final but this is not recommended. Hibernate uses the proxy pattern for performance improvement during lazy association. By making an entity final, Hibernate will no longer be able to use a proxy as Java doesn't allow the final class to be extended.

26. @Id

    Each entity bean has to have a primary key, which you annotate on the class with the @Id annotation. We can use this annotation either in a field or in a setter method.

27. @GeneratedValue

    This annotation is used when we want Hibernate to assign the entity identifier automatically using either AUTO, IDENTITY, SEQUENCE, TABLE. If we don’t use this annotation, then the identifier must be manually assigned before saving the entity.

    _AUTO:_ Indicates that the persistence provider should pick an appropriate strategy for the particular database.

    _IDENTITY:_ Indicates that the persistence provider must assign the primary key for the entity using a database identity column. Ex: MySQL

    _SEQUENCE:_ Indicates that the persistence provider must assign primary keys for the entity using a database sequence. It uses @SequenceGenerator. Ex: Oracle

    _TABLE:_ Indicates that the persistence provider must assign primary keys for the entity using an underlying database table to ensure uniqueness. In this case, one extra table is created by Hibernate with the name hibernate_sequences and there will be two columns sequence_name and next_val. It internally uses @TableGenerator.

28. @SequenceGenerator

    A sequence is a database object that can be used as a source of primary key values. It is similar to the use of an identity column type, except that a sequence is independent of any particular table and can therefore be used by multiple tables. Some of the databases don’t support sequences. In this case the database sequence concept will not be utilized and it creates a new table like @TableGenerator.

    ```java
    @Id
    @SequenceGenerator(name="myseq",sequenceName="HIB_SEQ")
    @GeneratedValue(strategy=SEQUENCE,generator="seq")
    private Integer eid;
    ```

    In this annotation name attribute is mandatory. A new table will be created with the name `hib_seq`. If we don’t provide the sequenceName attribute then myseq table will be created.

29. @TableGenerator

    This annotation is used in a very similar way to the @SequenceGenerator annotation, but because it manipulates a standard database table to obtain its primary key values, instead of using a vendor-specific sequence object, it is guaranteed to be portable between database platforms. It is the same as `@GeneratedValue(strategy = GenerationType.TABLE)`. It creates a table with two columns `sequence_name` and `next_val`.

    ```java
    @Id
    @GeneratedValue(strategy=GenerationType.TABLE,generator="employee_generator")
    @TableGenerator(name="employee_generator", table="pk_table",
    pkColumnName="name", valueColumnName="value", allocationSize=100)
    private Integer eid;
    ```

    Only the name attribute is mandatory. Rest are optional.

30. @Embeddable/@Embedded

    We can use these annotations to embed one entity inside another entity, so they are mapped to a single table. @Embeddable is used to mark a class to be eligible as an embedded class. @Embedded is used in the field/attribute inside the parent class. We can change the column name of the embeddable class inside the parent class using these annotations. `@AttributeOverrides` & `@AttributeOverride`.

    ```java
    @Entity
    Class Employee{
    @Embedded
    @AttributeOverrides(value = @AttributeOverride(name = "city",
    column = @Column(name = "village")))
    private Address address;
    }
    @Embeddable
    Class Address{
    }
    ```

## Association/Mappings

31. @OneToOne

    There are primarily 4 ways to create one-to-one relationships between two entities.

    1. The first technique is widely used and uses a foreign key column in one of the tables.
    2. The second technique uses a rather known solution of having a join table to store the mapping between the first two tables.
    3. The third technique is something new that uses a common primary key in both tables.
    4. Using @MapsId annotation that uses common primary key in both the tables but different from 3rd approach. It copies primary key from child table and put into parent table as foreign key.

    **Using a Foreign Key Association/Join Column:** In this kind of association, a foreign key column is created in the owner entity. For example, we have made `Employee` entity as an owner, then an extra column `accountId` will be created in the `employee` table. This column will store the foreign key for the Account table.

    ```java
     @Table
     @Entity
     public class Employee implements Serializable {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private int eid;
       private String firstName;
       private String lastName;
       private double salary;
       @OneToOne(cascade = CascadeType.PERSIST)
       @JoinColumn(name = "accountId") // accountId will become foreign in employee table
       private Account account;
     }
    ```

    ```java
    @Table
    @Entity
    public class Account {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int aid;
      private String accountNo;
      private String branch;
    }
    ```

    ```java
    Employee employee = new Employee();
    employee.setFirstName("David");
    employee.setLastName("Warner");
    employee.setSalary(56789);
    Account account=new Account();
    account.setAccountNo("ACC123");
    account.setBranch("Australia");
    employee.setAccount(account);

    session.persist(employee);
    ```

    In the `Employee` class if don't cascade the `Account` class then we shall get an exception saying:

    ```java
    Exception in thread "main" java.lang.IllegalStateException: org.hibernate.TransientObjectException: object references an unsaved transient instance - save the transient instance before flushing: com.altafjava.entity.Account
    ```

    If we want no cascading then 1st we need to persist the Account entity then persist the Employee entity.

    ```java
    Account account=new Account();
    account.setAccountNo("ACC123");
    account.setBranch("Australia");
    session.persist(account);

    Employee employee = new Employee();
    employee.setFirstName("David");
    employee.setLastName("Warner");
    employee.setSalary(56789);
    employee.setAccount(account);
    session.persist(employee);
    ```

    Generated Query:

    ```sql
    Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), primary key (aid)) engine=MyISAM

    Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, accountId integer, primary key (eid)) engine=MyISAM

    Hibernate: alter table Employee add constraint FKcs7jiub5myswnmgqtnp1uj1fi foreign key (accountId) references Account (aid)

    Hibernate: insert into Account (accountNo, branch) values (?, ?)

    Hibernate: insert into Employee (accountId, firstName, lastName, salary) values (?, ?, ?, ?)

    Hibernate: select e1_0.eid,a1_0.aid,a1_0.accountNo,a1_0.branch,e1_0.firstName,e1_0.lastName,e1_0.salary from Employee e1_0 left join Account a1_0 on a1_0.aid=e1_0.accountId where e1_0.eid=?
    ```

    If we don't write `@JoinColumn` in the owner entity `Employee` then defaults apply. A new column will be created in the parent table `Employee` with name `account_aid`. Means concatenation of child table name(account), underscore(\_) and child table primary key(aid).

    ```sql
    Hibernate: alter table Employee add constraint FKf5cbit5cfn86kiuergvpbidcr foreign key (account_aid) references Account (aid)
    ```

    In a bidirectional association, only one of the sides has to be the owner. The owner is responsible for the association column(s) update. The child entity who is not responsible of managing the relationship uses `mappedBy` attribute in @OneToOne annotation. The `mappedBy` refers to the property name which is declared in the owner's side.

    ```java
    public class Account {
      private int aid;
      private String accountNo;
      private String branch;
      @OneToOne(mappedBy = "account")
      private Employee employee;
    }
    ```

    If we don't use this `mappedBy` attribute then both the table will become owner table and stores the foreign key of each others. Employee will store Account's primary and Account will store Employee's primary key.

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), employee_eid integer, primary key (aid)) engine=MyISAM

      Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, accountId integer, primary key (eid)) engine=MyISAM

      Hibernate: alter table Account add constraint FKehpisc8myx4mq7peeu83gl5c4 foreign key (employee_eid) references Employee (eid)

      Hibernate: alter table Employee add constraint FKrwcsuf6gqdo5nbhro5avjqg6y foreign key (accountId) references Account (aid)

      Hibernate: insert into Account (accountNo, branch, employee_eid) values (?, ?, ?)

      Hibernate: insert into Employee (accountId, firstName, lastName, salary) values (?, ?, ?, ?)
    ```

    **Using a link table/Join Table:** In this approach, Hibernate will create a new table/link table that will store the primary key values from both the entities. In this technique `@JoinTable` is used. This annotation is used to define the new table and foreign keys from both of the tables.

    ```java
      @Table
      @Entity
      public class Employee  {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int eid;
         private String firstName;
         private String lastName;
         private double salary;
         @OneToOne(cascade = CascadeType.PERSIST)
         @JoinTable(name = "employee_account", joinColumns = @JoinColumn(name = "employeeId"), inverseJoinColumns = @JoinColumn(name = "accountId"))
         private Account account;
      }
    ```

    ```java
      @Table
      @Entity
      public class Account {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int aid;
         private String accountNo;
         private String branch;
      }
    ```

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), primary key (aid)) engine=MyISAM

      Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, primary key (eid)) engine=MyISAM

      Hibernate: create table employee_account (accountId integer, employeeId integer not null, primary key (employeeId)) engine=MyISAM

      Hibernate: alter table employee_account add constraint FKcf0q6b690ussmm11u4s08nixj foreign key (accountId) references Account (aid)

      Hibernate: alter table employee_account add constraint FKnvb8g9m5qlhk1752cq9muifk7 foreign key (employeeId) references Employee (eid)

      Hibernate: insert into Account (accountNo, branch) values (?, ?)

      Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)

      Hibernate: insert into employee_account (accountId, employeeId) values (?, ?)
    ```

    `@JoinTable` annotation is used in `Employee` entity class. It declares that a new table `employee_account` will be created with two columns `employeeId` (primary key of employee table) and `accountId` (primary key of account table). In this annotation `name` attribute is mandatory, rest are optional. So, if we write only

    ```java
    @JoinTable(name="employee_account")
    private Account account;
    ```

    then still it will work. It will create column names as `account_aid`(concatenation of child table name, underscore and primary key of its table) & `eid`(primary key of the owner entity).

    If we want bidirectional association then in the child entity we can use either `@OneToOne(mappedBy = "account")` or `@JoinTable` with `@OneToOne`. If we want to use `@JoinTable` then we must use `@OneToOne` with or without `mappedBy`. If we only use `@JoinTable` without `@OneToOne` then one extra column `employee` will be created in the account table with empty value.

    ```java
      public class Account {
         private int aid;
         private String accountNo;
         private String branch;
         @OneToOne(mappedBy = "account")
         // @JoinTable(name = "employee_account", joinColumns = @JoinColumn(name = "accountId"), inverseJoinColumns = @JoinColumn(name = "employeeId"))
         private Employee employee;
      }
    ```

    If we don't write `mappedBy` attribute then `Account` entity will create an extra column `employee_eid` as foreign key and store Employee's primary key.

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), employee_eid integer, primary key (aid)) engine=MyISAM

      Hibernate: alter table Account add constraint FKejw579y4swv5plx8wfxh4bxk5 foreign key (employee_eid) references Employee (eid)
    ```

    **Using a Shared Primary Key:** In this technique, Hibernate will ensure that it will use a common primary key value in both tables. This way primary key of `Employee` Entity can safely be assumed the primary key of `Account` Entity also. In this approach, `@PrimaryKeyJoinColumn` is the main annotation to be used in the owner's entity.

    ```java
      @Table
      @Entity
      public class Employee  implements Serializable{
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int eid;
         private String firstName;
         private String lastName;
         private double salary;
         @OneToOne(cascade = CascadeType.PERSIST)
         @PrimaryKeyJoinColumn
         private Account account;
      }
    ```

    ```java
      @Table
      @Entity
      public class Account implements Serializable{
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int aid;
         private String accountNo;
         private String branch;
      }
    ```

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), primary key (aid)) engine=MyISAM

      Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, primary key (eid)) engine=MyISAM

      Hibernate: insert into Account (accountNo, branch) values (?, ?)

      Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)
    ```

    If we want bidirectional association then in the child entity we need to use `@OneToOne(mappedBy = "account")`.

    ```java
      public class Account {
         private int aid;
         private String accountNo;
         private String branch;
         @OneToOne(mappedBy = "account")
         private Employee employee;
      }
    ```

    ```java
      Employee employee = new Employee();
      employee.setFirstName("David");
      employee.setLastName("Warner");
      employee.setSalary(56789);
      Account account = new Account();
      account.setAccountNo("ACC123");
      account.setBranch("Australia");
      employee.setAccount(account); // this is enough for bidirectional association
      //	account.setEmployee(employee); // this line is optional
      session.persist(employee);
    ```

    If we don't write `mappedBy` attribute then `Account` entity will create an extra column `employee_eid` as foreign key and store Employee's primary key.

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), employee_eid integer, primary key (aid)) engine=MyISAM

      Hibernate: alter table Account add constraint FKejw579y4swv5plx8wfxh4bxk5 foreign key (employee_eid) references Employee (eid)
    ```

    **Using a Shared Primary Key:** In this technique, Hibernate assumes both the source and target share the same primary key values. For that we use `@MapsId` annotation. The parent-side association becomes redundant(its primary key will no longer be needed).

    ```java
      @Table
      @Entity
      public class Employee  implements Serializable{
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int eid;
         private String firstName;
         private String lastName;
         private double salary;
         @OneToOne(cascade = CascadeType.PERSIST)
         @MapsId
         private Account account;
      }
    ```

    ```java
      @Table
      @Entity
      public class Account implements Serializable{
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int aid;
         private String accountNo;
         private String branch;
         @OneToOne(mappedBy = "account")
         private Employee employee;
      }
    ```

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), primary key (aid)) engine=MyISAM

      Hibernate: create table Employee (firstName varchar(255), lastName varchar(255), salary float(53) not null, account_aid integer not null, primary key (account_aid)) engine=MyISAM

      Hibernate: alter table Employee add constraint FKf5cbit5cfn86kiuergvpbidcr foreign key (account_aid) references Account (aid)

      Hibernate: insert into Account (accountNo, branch) values (?, ?)

      Hibernate: insert into Employee (firstName, lastName, salary, account_aid) values (?, ?, ?, ?)
    ```

    **Note:** For bidirectional association any of the technique it is must to write `@OneToOne` annotation either with or without `mappedBy` attribute. If not then we shall get exception:

    ```java
    Exception in thread "main" jakarta.persistence.PersistenceException: Converting `org.hibernate.exception.DataException` to JPA `PersistenceException` : could not execute statement

    Caused by: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column 'employee' at row 1
    ```

32. @OneToMany

    We can implement one to many association in 2 ways.

    1. Using foreign key column.
    2. Using link table.

    **Using foreign key column:** In this approach child table(Account) column will refer to the primary key of parent table(Employee).

    ```java
      @Table
      @Entity
      public class Employee implements Serializable {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int eid;
         private String firstName;
         private String lastName;
         private double salary;
         @OneToMany(cascade = CascadeType.PERSIST, mappedBy = "employee")
         private List<Account> accounts;
      }
    ```

    ```java
      @Entity
      @Table
      public class Account implements Serializable {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int aid;
         private String accountNo;
         private String branch;
         @ManyToOne
         @JoinColumn(name = "employeeId")
      	private Employee employee;
      }
    ```

    ```java
      Employee employee = new Employee();
      employee.setFirstName("David");
      employee.setLastName("Warner");
      employee.setSalary(56789);
      Account account = new Account();
      account.setAccountNo("ACC123");
      account.setBranch("Australia");
      account.setEmployee(employee);
      List<Account> accounts = new ArrayList<>();
      accounts.add(account);
      account = new Account();
      account.setAccountNo("BCC567");
      account.setBranch("New Zealand");
      accounts.add(account);
      employee.setAccounts(accounts);
      account.setEmployee(employee);

      Transaction transaction = session.beginTransaction();
      session.persist(employee);
      transaction.commit();

      Employee employee2 = session.get(Employee.class, 1);
    ```

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), employeeId integer, primary key (aid)) engine=MyISAM

      Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, primary key (eid)) engine=MyISAM

      Hibernate: alter table Account add constraint FKbkyxfxqy2qresbaghdbm5xtty foreign key (employeeId) references Employee (eid)

      Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)

      Hibernate: insert into Account (accountNo, branch, employeeId) values (?, ?, ?)

      Hibernate: insert into Account (accountNo, branch, employeeId) values (?, ?, ?)

      -: SELECT QUERIES :-

      Hibernate: select e1_0.eid,e1_0.firstName,e1_0.lastName,e1_0.salary from Employee e1_0 where e1_0.eid=?

      Hibernate: select a1_0.employeeId,a1_0.aid,a1_0.accountNo,a1_0.branch from Account a1_0 where a1_0.employeeId=?
    ```

    **Using link table/Join Table:** This approach uses the `@JoinTable` annotation to create a link table that stores the foreign keys of both the tables.

    ```java
      @Entity
      public class Employee implements Serializable {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int eid;
         private String firstName;
         private String lastName;
         private double salary;
         @OneToMany(cascade = CascadeType.PERSIST)
         @JoinTable(name = "empacc", joinColumns = @JoinColumn(name = "employeeId"), inverseJoinColumns = @JoinColumn(name = "accountId"))
         private List<Account> accounts;
      }
    ```

    ```java
      @Entity
      public class Account implements Serializable {
         @Id
         @GeneratedValue(strategy = GenerationType.IDENTITY)
         private int aid;
         private String accountNo;
         private String branch;
         @ManyToOne
         @JoinTable(name = "empacc", joinColumns = @JoinColumn(name = "accountId"), inverseJoinColumns = @JoinColumn(name = "employeeId"))
         private Employee employee;
      }
    ```

    ```java
      Employee employee = new Employee();
      employee.setFirstName("David");
      employee.setLastName("Warner");
      employee.setSalary(56789);
      Account account = new Account();
      account.setAccountNo("ACC123");
      account.setBranch("Australia");
      List<Account> accounts = new ArrayList<>();
      accounts.add(account);
      account = new Account();
      account.setAccountNo("BCC567");
      account.setBranch("New Zealand");
      accounts.add(account);
      employee.setAccounts(accounts);

      Transaction transaction = session.beginTransaction();
      session.persist(employee);
      transaction.commit();
    ```

    ```sql
      Hibernate: create table Account (aid integer not null auto_increment, accountNo varchar(255), branch varchar(255), primary key (aid)) engine=MyISAM

      Hibernate: create table empacc (employeeId integer, accountId integer not null, primary key (accountId)) engine=MyISAM

      Hibernate: create table Employee (eid integer not null auto_increment, firstName varchar(255), lastName varchar(255), salary float(53) not null, primary key (eid)) engine=MyISAM

      Hibernate: alter table empacc add constraint FKp2jrrkjsg7pyp97t7xn0480yj foreign key (employeeId) references Employee (eid)

      Hibernate: alter table empacc add constraint FK897b88v7cuvxmstxhqmad0dbe foreign key (accountId) references Account (aid)

      Hibernate: insert into Employee (firstName, lastName, salary) values (?, ?, ?)

      Hibernate: insert into Account (accountNo, branch) values (?, ?)

      Hibernate: insert into Account (accountNo, branch) values (?, ?)

      Hibernate: insert into empacc (employeeId, accountId) values (?, ?)

      Hibernate: insert into empacc (employeeId, accountId) values (?, ?)
    ```

33. @ManyToMany

    A many-to-many association is made between two entities where many entities can be associated with multiple other entities. For example, for a subscription service, `Subscription` Entity and `Reader` Entity can be two types of entities. A given subscription can have multiple readers, whereas a reader can subscribe to multiple subscriptions. Many to many association requires a link table that joins two entities. It stores the foreign key of both the tables. This annotation doesn't require `@JoinTable`. `@ManyToMany` annotation is enough to create the link table.

    ```java
    @Entity
    public class Reader implements Serializable {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int rid;
      private String readerName;
      private String email;
      @ManyToMany(cascade = CascadeType.PERSIST)
      private List<Subscription> subscriptions;
    }
    ```

    ```java
    @Entity
    public class Subscription implements Serializable {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int sid;
      private String subscriptionName;
    }
    ```

    ```java
    Subscription subscription1 = new Subscription();
    subscription1.setSubscriptionName("Youtube");
    Subscription subscription2 = new Subscription();
    subscription2.setSubscriptionName("Netflix");
    List<Subscription> subscriptions = Arrays.asList(subscription1, subscription2);
    Reader reader = new Reader();
    reader.setEmail("abc@gmail.com");
    reader.setReaderName("David");
    reader.setSubscriptions(subscriptions);

    Transaction transaction = session.beginTransaction();
    session.persist(reader);
    transaction.commit();
    ```

    ```sql
      Hibernate: create table Reader (rid integer not null auto_increment, email varchar(255), readerName varchar(255), primary key (rid)) engine=MyISAM

      Hibernate: create table Reader_Subscription (Reader_rid integer not null, subscriptions_sid integer not null) engine=MyISAM
      Hibernate: create table Subscription (sid integer not null auto_increment, subscriptionName varchar(255), primary key (sid)) engine=MyISAM

      Hibernate: alter table Reader_Subscription add constraint FKs066tyf8j84vwtv387hbboow9 foreign key (subscriptions_sid) references Subscription (sid)

      Hibernate: alter table Reader_Subscription add constraint FKld5v1st16r4u53vufetlbodh5 foreign key (Reader_rid) references Reader (rid)

      Hibernate: insert into Reader (email, readerName) values (?, ?)

      Hibernate: insert into Subscription (subscriptionName) values (?)

      Hibernate: insert into Subscription (subscriptionName) values (?)

      Hibernate: insert into Reader_Subscription (Reader_rid, subscriptions_sid) values (?, ?)

      Hibernate: insert into Reader_Subscription (Reader_rid, subscriptions_sid) values (?, ?)
    ```

    If we want bidirectional association then in the child class we need to use `@ManyToMany` with `mappedBy` attribute. Rest everything will be same. Even generated SQL query will be same.

    ```java
    @Entity
    public class Subscription implements Serializable {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int sid;
      private String subscriptionName;
      @ManyToMany(mappedBy = "subscriptions")
      List<Reader> readers;
    }
    ```

34. @ManyToOne

    A many-to-one association is made between two entities where many entities can be associated with one entity. For example, Many students work on a single project. In this association, many side will be the owner and creates a foreign key column in its table.

    ```java
    @Entity
    public class Student implements Serializable {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int sid;
      private String name;
      @ManyToOne(cascade = CascadeType.PERSIST)
      @JoinColumn(name = "projectId")
      private Project project;
    }
    ```

    ```java
    @Entity
    @Data
    @ToString(exclude = "students")
    public class Project implements Serializable {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int pid;
      private String projectName;
      @OneToMany(mappedBy = "project")
      private List<Student> students;
    }
    ```

    ```java
      Transaction transaction = session.beginTransaction();
      Project project = new Project();
      project.setProjectName("HMS");

      Student student1 = new Student();
      student1.setName("Ajay");
      student1.setProject(project);
      session.persist(student1);

      Student student2 = new Student();
      student2.setName("David");
      student2.setProject(project);
      session.persist(student2);
      transaction.commit();
    ```

    ```sql
    Hibernate: create table Project (pid integer not null auto_increment, projectName varchar(255), primary key (pid)) engine=MyISAM

    Hibernate: create table Student (sid integer not null auto_increment, name varchar(255), projectId integer, primary key (sid)) engine=MyISAM

    Hibernate: alter table Student add constraint FKb3wn40e1o66egelusymas8fvo foreign key (projectId) references Project (pid)

    Hibernate: insert into Project (projectName) values (?)

    Hibernate: insert into Student (name, projectId) values (?, ?)

    Hibernate: insert into Student (name, projectId) values (?, ?)
    ```

- Difference between positional & named parameters?
- What is the use of uniqueResult() method?
- Aggregate Functions.
- Order By clause.
- What is named query? How many types of named queries?
- What is Join and what are the different types?
- How we can use pagination in Hibernate?
- What is Id Generators? What are the different ID Generates are used by -Hibernate?
- What are the JPA annotations for ID Generators?
- How many types of Mapping in Hibernate?(Basic ORM Mapping, Component Mapping, Inheritance Mapping, Collection Mapping, Association Mapping)
- What is Component Mapping?
- What is Inheritance Mapping and its type?(Table per class hierarchy, Table per subclass, Table per concrete class)
- What is Association Mapping and its type?(1:1, 1:N, N:1, N:N)
- What is Criteria API?
- What is Projection?
